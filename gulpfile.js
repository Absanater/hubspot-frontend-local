const gulp = require('gulp');
const sass = require('gulp-sass');
const browserSync = require('browser-sync').create();
const sassLint = require('gulp-sass-lint');
const concat = require('gulp-concat');
const eslint = require('gulp-eslint');
const lintRulesPath = './.eslintrc';
const autoprefixer = require('gulp-autoprefixer');
const minifyCSS = require('gulp-clean-css');
const minifyJS = require('gulp-uglify');
const fs = require('fs');
const rp = require('request-promise');
const config = require('./config.json');
const headerComment = require('gulp-header-comment');
const runSeq = require('run-sequence');
const readlineSync = require('readline-sync');
const browserify = require("browserify");
const babelify = require("babelify");
const source = require('vinyl-source-stream');
const gutil = require('gulp-util');
const buffer = require('vinyl-buffer');


function getFilePath(id) {
  let options = {
    method: 'GET',
    uri: `http://api.hubapi.com/content/api/v2/templates/${id}?hapikey=${config.api_key}`,
  };

  return rp(options);
}

gulp.task('sass-lint', () => {
    return gulp.src('./src/styles/*.scss')
        .pipe(sassLint({
          rules: {
            'mixins-before-declarations': 0,
            'no-transition-all': 0,
            'no-color-keywords': 0,
            'no-color-literals': 0,
            'property-sort-order': 0
          }
        }))
        .pipe(sassLint.format())
        .pipe(sassLint.failOnError())
});

gulp.task('eslint', ['scripts'], () => {
  gulp.src(["./src/scripts/**/*.js"])
    .pipe(eslint())
    .pipe(eslint.format());
});

gulp.task('scripts', () => {
  return browserify({ debug: true })
    .transform(babelify)
    .require("./src/scripts/main.js", { entry: true })
    .bundle()
    .on('error', function (err) {
      console.log(err);
      process.exit(1);
    })
    .pipe(source('main.js'))
    .pipe(buffer())
    .pipe(minifyJS())
    .pipe(headerComment(`THIS FILE WAS AUTOGENERATED FROM https://bitbucket.org/growthfunders/hubspot-dev/ 
    PLEASE CREATE A BRANCH HERE IF YOU WANT TO MAKE CHANGES`))
    .pipe(gulp.dest('./dist'));
});

gulp.task('concat-head', () => {
  const main =  gulp.src('./src/styles/main.scss')
    .pipe(sass())
    .pipe(minifyCSS())
    .pipe(autoprefixer())

  return main
    .pipe(concat('main.css'))
    .pipe(headerComment("THIS FILE WAS AUTOGENERATED PLEASE DO NOT EDIT, RISK OF OVERWRITE"))
    .pipe(gulp.dest('dist'))
    .pipe(browserSync.reload({stream: true}));
});

gulp.task('servePage', () => {
  let {css, js} = config.files;

  const jsRewrite = [];

  let showCss = {
    rule: {
      match: /<\/head>/i,
      fn: function (snippet, match) {
        return snippet + match;
      }
    }
  };

  const jsRegex = new Promise((resolve, reject) => {
    if (js.useLocal) {
      if (js.overWriteLocal) {
        const fileLocation = getFilePath(js.id).then((body) => {
          let {path} = JSON.parse(body);
          let regVal = `<script .*${path.replace('.js', '')}.*\.js.*><\/script>`;
          let regex = new RegExp(regVal);

          jsRewrite.push({
            match: regex,
            fn: function(req, res, match) {
              return '<script src="/main.js"></script>';
            }
          });
          resolve();
        }).catch(() => resolve());
      } else {
        jsRewrite.push({
          match: /<\/body>/i,
          fn: function(req, res, match) {
            return '<script src="/main.js"></script>' + match;
          }
        });
        resolve();
      }
    } else {
      resolve();
    }
  });

  const cssRegex = new Promise((resolve, reject) => {
    if (css.useLocal) {
      if (css.overWriteLocal) {
        const fileLocation = getFilePath(css.id).then((body) => {
          let {path} = JSON.parse(body);
          let regVal = `<link.*${path.replace('.css', '')}.*.css.*>`;
          let regex = new RegExp(regVal);

          showCss = {
            rule: {
              match: regex,
              fn: function (snippet, match) {
                return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet;
              }
            }
          }

          resolve();
        }).catch(() => resolve());
      } else {
        showCss = {
          rule: {
            match: /<\/head>/i,
            fn: function (snippet, match) {
              return '<link rel="stylesheet" type="text/css" href="/main.css"/>' + snippet + match;
            }
          }
        }
        resolve();
      }
    } else {
      resolve();
    }
  });

  console.log(`
  Please wait while we get your file paths.
  `);

  Promise.all([jsRegex, cssRegex]).then(() => {
    browserSync.init({
      proxy: {
        target: process.env.npm_config_myPage
      },
      serveStatic: ["dist"],
      files: ["dist/**"],
      snippetOptions: showCss,
      rewriteRules: jsRewrite,
      ghostMode: {
        scroll: true
      },
      open: true
    });
    gulp.watch('./src/styles/*.scss', ['sass-lint' ,'concat-head', browserSync.reload]);
    gulp.watch('./src/scripts/*.js', ['eslint', browserSync.reload]);
  });
});

gulp.task('assets-prompt', () => {
  if (readlineSync.keyInYN('Are you sure you want to deploy your files? This will overwrite the files already here. (Y for yes, N for no)')) {
    return true;
  }
  console.log('Ok, not deploying. Please update the config and try and again');
  process.exit(1);
});

gulp.task('design-manager', () => {
  let {api_key, files} = config;

  const file = fs.readFileSync(__dirname + '/dist/main.js', 'utf8');

  Object.keys(files).forEach(function(file) {
    let thisFile = files[file];
    if (!thisFile.useLocal) return;

    if (!thisFile.id) return console.error(`Please give your ${file} file an ID in config.json`);

    let fileString = fs.readFile(__dirname + thisFile.path, (err, data) => {
      if (err) return console.error(err);


      let source = JSON.stringify({
        "source":data.toString()
      });

      let options = {
        method: 'PUT',
        uri: `http://api.hubapi.com/content/api/v2/templates/${thisFile.id}?hapikey=${api_key}`,
        headers: {
          'Content-Type': 'application/json'
        },
        body: source
      };

      rp(options)
        .then(function (body) {
          let {label, folder_id, path} = JSON.parse(body);
          console.log(`
          File: ${folder_id}
          Label: ${label}
          At: ${path}
          Successfully updated`);
        })
        .catch(function (err) {
          return console.error('Upload Failed:', err);
        });

    });
  })
});

gulp.task('build', ['concat-head', 'scripts']);
gulp.task('default', ['build', 'servePage']);

gulp.task('assets', function () {
  return runSeq('assets-prompt', ['concat-head', 'scripts'], 'design-manager');
})
